\# 深入理解JVM Based on JDK1.7

# Part 1 走进Java
## 1 走进Java

# Part 2 自动内存管理机制
## 2 Java内存区域与内存溢出异常
### 2.1 概述
>内存自动回收

### 2.2 运行时数据区域
![Java Running Data Area](https://github.com/rayshaw001/common-pictures/blob/master/deep%20in%20JVM/JavaRunningDataArea.jpg?raw=true)

#### 2.2.1 程序计数器

1. 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器
2. Native方法的计数器值为空（undifined）

#### 2.2.2 Java 虚拟机栈

#### 2.2.3 本地方法栈

#### 2.2.4 Java 堆

#### 2.2.5 方法区

#### 2.2.6 运行常量池

1. Runtime Constant Pool是方法区的一部分
2. 

#### 2.2.7 直接内存

### 2.3 访问对象

### 2.4 实战： OutOfMemoryError 异常

##### 2.4.1 Java堆溢出

1. 保证GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象
2. 内存堆转储快照以便事后分析



## 3 垃圾收集器与内存分配策略
### 3.2 对象已死？

#### 3.2.1 引用计数法

#### 3.2.2 根搜索算法

#### 3.2.3 再谈引用

1. 强引用
2. 软引用
3. 弱引用
4. 虚引用

#### 3.2.4 生存还是死亡？

1. finalize()方法只会被系统调用一次
2. finalize()能做的工作，使用try-finally或其他方式都可以做得更好、更及时

#### 3.2.5 回收方法区

### 3.3 垃圾收集算法
#### 3.3.1 标记-清除算法
#### 3.3.2 复制算法
#### 3.3.3 标记-整理算法
#### 3.3.4 分代手机算法

### 3.4 垃圾收集器

1. 收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。

![JVMCollectors](https://github.com/rayshaw001/common-pictures/blob/master/deep%20in%20JVM/JVMCollectors.jpg?raw=true)

#### 3.4.1 Serial收集器
1. 单线程
2. Stop The World
3. 简单高效
4. 常用于client

#### 3.4.2 ParNew 收集器
1. ParNew 收集器其实就是Serial收集器的多线程版本

#### 3.4.3 Parallel Scavenge 收集器
1. 目标是达到一个可控的吞吐量，吞吐量= 运行用户代码时间/（运行用户代码时间+垃圾手机时间）
2. 停顿时间短 适合需要与用户交互的程序
3. 高吞吐量   适合在后台运算而不需要太多交互的任务

#### 3.4.4 Serial Old 收集器

#### 3.4.5 Parallel Old 收集器

#### 3.4.6 CMS 收集器

#### 3.4.7 G1收集器

#### 3.4.8 垃圾收集器参数总结

### 3.5 内存分配与回收策略

#### 3.5.1 对象优先在Eden分配

#### 3.5.2 大对象直接进入老年代

#### 3.5.3 长期存活的对象将进入老年代

#### 3.5.4 动态对象年龄判定

#### 3.5.5 空间分配担保

### 3.6 本章小结


## 4 虚拟机性能监控与故障处理工具

## 5 调优案例分析与实战

# Part 3 虚拟机执行子系统
## 6 类文件结构

## 7 虚拟机类加载机制

## 8 虚拟机字节码执行引擎

## 9 类加载及执行子系统的案例与实战

# Part 4 程序编译与代码优化
## 10 早期（编译期）优化

## 11 晚期（运行期）优化

# Part5 高效并发
## 12 Java内存模型与线程

## 13 线程安全与锁优化
