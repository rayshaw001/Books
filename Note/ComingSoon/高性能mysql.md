\# High Performance MySQL,Third Edition
# 1 MySQL 架构与历史
## 1.1 MySQL逻辑架构
### 1.1.1 连接管理与安全性
### 1.1.2 优化与执行
## 1.2 并发控制
### 1.2.1 读写锁

```
共享锁  ->  读锁
排它锁  ->  写锁
```
### 1.2.2 锁粒度

```
表锁（MyISAM）：
行锁（InnoDB）：最大程度地提供并发，同时也带来了最大的开销
```
## 1.3 事务

```
A：原子性
C：一致性
I：隔离性
D：持久性
```
### 1.3.1 隔离级别

```
读未提交
读提交
可重复读
序列化
```
\# MVCC
### 1.3.2 死锁
>InnoDB 目前处理死锁的办法是：将持有最少行级排它锁的事务进行回滚
### 1.3.3 事务日志
>预写式日志
### 1.3.4 MySQL中的事务

```
MySQL提供两种事务型的存储引擎：InnoDB和NDB Cluster

MySQL默认采用自动提交模式
事务型表（InnoDB）和非事务型表混用，正常提交数据不会有问题，但是如果事务需要回滚，那么非事务型表就表现得无法回滚，从而导致数据变更无法撤销
```
## 1.4 多版本并发控制

```
MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低
InnoDB 的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间
```
## 1.5 MySQL 的存储引擎
### 1.5.1 InnoDB存储引擎
### 1.5.2 MyISAM存储引擎
### 1.5.3 MySQL内建的其他引擎
### 1.5.4 第三方存储引擎
### 1.5.5 选择合适的存储引擎
### 1.5.6 转换表的引擎
## 1.6 MySQL 时间线
## 1.7 MySQL的开发模式
## 1.8 总结

# 2 MySQL基准测试
## 2.1 为什么需要基准测试
## 2.2 基准测试策略
### 2.2.1 测试何种指标
## 2.3 基准测试方法
### 2.3.1 设计和规划基准测试
### 2.3.2 基准测试应该运行多长时间
### 2.3.3 获取系统性能和状态
### 2.3.4 获得准确的测试结果
### 2.3.5 运行基准测试并分析结果
### 2.3.6 绘图的重要性
## 2.4 基准测试工具
### 2.4.1 集成式测试工具
### 2.4.2 单组件式测试工具
## 2.5 基准测试案例
### 2.5.1 http_load
### 2.5.2 MySQL 基准测试套件
### 2.5.3 sysbench
### 2.5.4 数据库测试套件中的dbt2 TPC-C测试
### 2.5.5 Percona的TPCC-MySQL测试工具
## 2.6 总结

# 3 服务器性能剖析
## 3.1 性能优化简介
### 3.1.1 通过性能剖析进行优化
### 3.1.2 理解性能剖析
## 3.2 对应用程序进行性能剖析
### 3.2.1 测量PHP应用程序
## 3.3 剖析MySQL查询
### 3.3.1 剖析服务器负载
### 3.3.2 剖析单条查询
### 3.3.3 使用性能剖析
## 3.4 诊断间歇性问题
### 3.4.1 单条查询问题还是服务器问题
### 3.4.2 捕获诊断数据
### 3.4.3 一个诊断案例
## 3.5 其他剖析工具
### 3.5.1 使用USER_STATISTICS表
### 3.5.2 使用strace
## 3.6 总结

# 4 Schema与数据类型优化
## 4.1 选择优化的数据类型
### 4.1.1 整数类型
### 4.1.2 实数类型
### 4.1.3 字符串类型
### 4.1.4 日期和时间类型
### 4.1.5 位数据类型
### 4.1.6 选择表示符（identifier）
### 4.1.7 特殊类型数据
## 4.2 MySQL schema设计中的陷阱
## 4.3 范式和反范式
### 4.3.1 范式的有点和缺点
### 4.3.2 反范式的有点和缺点
### 4.3.3 混用范式化和反范式化
## 4.4 缓存表和汇总表
### 4.4.1 物化视图
### 4.4.2 计数器表
## 4.5 加快ALTER TABLE 操作的速度
### 4.5.1 只修改.frm文件
### 4.5.2 快速创建MyISAM索引
## 4.6 总结

# 5 创建高性能的索引
## 5.1 索引基础
### 5.1.1 索引的类型
> B-Tree索引
## 5.2 索引的有点
## 5.3 高性能的索引策略
### 5.3.1 独立的列
```
无法使用索引的示例：
SELECT * FROM db.table WHERE id + 1 = 5;
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <=10;
```
### 5.3.2 前缀索引和索引选择性
### 5.3.3 多列索引
### 5.3.4 选择合适的索引列顺序
### 5.3.5 聚簇索引
### 5.3.6 覆盖索引
### 5.3.7 使用索引扫描来做排序
### 5.3.8 压缩（前缀压缩）索引
### 5.3.9 冗余和重复索引
### 5.3.10 未使用的索引
### 5.3.11 索引和锁
## 5.4 索引案例学习
### 5.4.1 支持多种过滤条件
### 5.4.2 避免多个范围条件
### 5.4.3 优化排序
## 5.5 维护索引和表
### 5.5.1 找到并修复顺坏的表
### 5.5.2 更新索引统计信息
### 5.5.3 减少索引和数据的碎片
## 5.6 总结

# 6 查询性能优化
## 6.1 为什么查询速度会慢
## 6.2 慢查询基础：优化数据访问
### 6.2.1 是否想服务器请求了不需要的数据
### 6.2.2 MySQL是否在扫描额外的记录
## 6.3 重构查询的方式
### 6.3.1 一个复杂查询还是多个简单查询
### 6.3.2 切分查询
### 6.3.3 分解关联查询
## 6.4 查询执行的基础
### 6.4.1 MySQL客户端/服务器通信协议
### 6.4.2 查询缓存
### 6.4.3 查询优化处理
### 6.4.4 查询执行引擎
### 6.4.5 返回结果给客户
## 6.5 MySQL查询优化器大的局限性
### 6.5.1 关联子查询
### 6.5.2 UNION的限制
### 6.5.3 索引合并优化
### 6.5.4 等值传递
### 6.5.5 并行执行
### 6.5.6 哈希关联
### 6.5.7 松散索引扫描
### 6.5.8 最大值和最小值优化
### 6.5.9 在同一个表上查询和更新
## 6.7 优化特定类型的查询
### 6.7.1 优化COUNT()查询
### 6.7.2 优化关联查询
### 6.7.3 优化子查询
### 6.7.4 优化GROUP BY和DISTINCT
### 6.7.5 优化LIMIT分页
### 6.7.6 优化SQL_CALC_FOUND_RAWS
### 6.7.7 优化UNION查询
### 6.7.8 静态分析查询
### 6.7.9 使用用户自定义的变量
## 6.8 案例学习
### 6.8.1 使用MySQL构建一个队列表
### 6.8.2 计算亮点之间的距离
### 6.8.3 使用
## 6.9 总结

# 7 MySQL 高级特性
## 7.1 分区表
### 7.1.1 分区表的原理
### 7.1.2 分区表的类型
### 7.1.3 如何使用分区表
### 7.1.4 什么情况下会出问题
### 7.1.5 查询优化
### 7.1.6 合并表
## 7.2 视图
### 7.2.1 可更新视图
### 7.2.2 视图对性能的影响
### 7.2.3 视图的限制
## 7.3 外键约束
## 7.4 在MySQL内部存储代码
### 7.4.1 存储过程和函数
### 7.4.2 触发器
### 7.4.3 事件
### 7.4.4 在存储过程中保留注释
## 7.5 游标
## 7.6 绑定变量
### 7.6.1 绑定变量的优化
### 7.6.2 SQL接口的绑定变量
### 7.6.3 绑定变量的限制
## 7.7 用户自定义函数
## 7.8 插件
## 7.9 字符集和校对
### 7.9.1 MySQL如何使用字符集
### 7.9.2 选择字符集和校对规则
### 7.9.3 字符集和校对规则
## 7.10 全文索引
### 7.10.1 自然语言的全文索引
### 7.10.2 布尔全文索引
### 7.10.3 MySQL5.1 中全文索引的变化
### 7.10.4 全文索引的限制和替代方案
### 7.10.5 全文索引的配置和优化
## 7.11 分布式（XA）事务
### 7.11.1 内部XA事务
### 7.11.2 外部XA事务
## 7.12 查询缓存
### 7.12.1 MySQL如何判断缓存命中
### 7.12.2 查询缓存如何使用内存
### 7.12.3 什么情况下查询缓存能发挥作用
### 7.12.4 如何配置和维护查询缓存
### 7.12.5 InnoDB和查询缓存
### 7.12.6 通用查询缓存优化
### 7.12.7 查询缓存的替代方案
## 7.13 总结

# 8 优化服务器设置
## 8.1 MySQl配置的工作原理
### 8.1.1 语法、作用域和动态性
### 8.1.2 设置变量的副作用
### 8.1.3 入门
### 8.1.4 通过基准测试迭代优化
## 8.2 什么不该做
## 8.3 创建MySQL配置文件
### 8.3.1 检查MySQL服务器状态变量
## 8.4 配置内存使用
### 8.4.1 MySQL可以使用多少内存？
### 8.4.2 每个连接需要的内存
### 8.4.3 为操作系统保留内存
### 8.4.4 为缓存分配的内存
### 8.4.5 InnoDB 缓冲池（Buffer Pool）
### 8.4.6 MyISAM键缓存（Key Caches）
### 8.4.7 线程缓存
### 8.4.8 表缓存（Table Cache）
### 8.4.9 InnoDB数据字典（Data Dictionary）
## 8.5 配置MySQL的I/O行为
### 8.5.1 InnoDB I/O配置
### 8.5.2 MyISAM的 I/O配置
## 8.6 配置MySQL并发
### 8.6.1 InnoDB并发配置
### 8.6.2 MyISAM并发配置
## 8.7 基于工作负载的配置
### 8.7.1 优化BLOB和TEXT的场景
### 8.7.2 优化排序（Filesorts）
## 8.8 完成基本配置
## 8.9 安全和稳定的设置
## 8.10 该机InnoDB设置
## 8.11 总结

# 9 操作系统和硬件优化
## 9.1 什么限制了MySQL的性能
## 9.2 如何为MySQL选择CPU
### 9.2.1 哪个更好：更快的CPU还是更多的CPU
### 9.2.2 CPU架构
### 9.2.3 扩展到多个CPU和核心
## 9.3 平衡内存和磁盘资源
### 9.3.1 随机I/O和顺序I/O
### 9.3.2 缓存、读和写
### 9.3.3 工作集是什么
### 9.3.4 找到有效的内存/磁盘比例
### 9.3.5 选择硬盘
## 9.4 固态存储
### 9.4.1 闪存概述
### 9.4.2 闪存技术
### 9.4.3 闪存的基准测试
### 9.4.4 固态硬盘驱动器
### 9.4.5 PCIe存储设备
### 9.4.6 其他类型的固态存储
### 9.4.7 什么时候应该使用闪存
### 9.4.8 使用flashcache
### 9.4.9 优化固态存储上的MySQL
## 9.5 为备库选择硬件
## 9.6 RAID性能优化
### 9.6.1 RAID的故障转移、恢复和镜像
### 9.6.2 平衡硬件RAID和软件RAID
### 9.6.3 RAID配置和缓存
## 9.7 SAN和NAS
### 9.7.1 SAN基准测试
### 9.7.2 使用基于NFS或SMB的SAN
### 9.7.3 MySQL在SAN上的性能
### 9.7.4 应该用SAN吗
## 9.8 使用多磁盘卷
## 9.9 网络配置
## 9.10 选择操作系统
## 9.11 选择文件系统
## 9.12 选择磁盘队列调度策略
## 9.13 线程
## 9.14 内存交换
## 9.15 操作系统状态
### 9.15.1 如何阅读vmstat的输出
### 9.15.2 如何阅读iostat的输出
### 9.15.3 其他有用的工具
### 9.15.4 CPU密集型的机器
### 9.15.5 I/O密集型的机器
### 9.15.6 发生内存交换的机器
### 9.15.7 空闲的机器
## 9.16 总结

# 10 复制
## 10.1 复制概述
### 10.1.1 复制解决的问题
### 10.1.2复制如何工作
## 10.2 配置复制
### 10.2.1 创建复制账号
### 10.2.2 配置主库和备库
### 10.2.3 启动复制
### 10.2.4 从另一个服务器开始复制
### 10.2.5 推荐的复制配置
## 10.3 复制的原理
### 10.3.1 基于语句的复制
### 10.3.2 基于行的复制
### 10.3.3 基于行或基于语句：哪种更优
### 10.3.4 复制文件
### 10.3.5 发送复制时间到其他备库
### 10.3.6 复制过滤器
## 10.4 复制拓扑
### 10.4.1 一主库多备库
### 10.4.2 主动-主动模式下的主-主复制
### 10.4.3 主动-被动模式下的主-主复制
### 10.4.4 拥有备库的主-主结构
### 10.4.5 环形复制
### 10.4.6 主库、分发主库以及备库
### 10.4.7 树或金字塔形
### 10.4.8 定制的复制方案
## 10.5 复制和容量规划
### 10.5.1 为什么复制无法扩展写操作
### 10.5.2 备库什么时候开始延迟
### 10.5.3 规划冗余容量
## 10.6 复制管理和维护
### 10.6.1 监控复制
### 10.6.2 测量备库延迟
### 10.6.3 确定主备是否一致
### 10.6.4 从主库重新同步备库
### 10.6.5 改变主库
### 10.6.6 在一个主-主配置中交换角色
## 10.7 复制的问题和解决方案
### 10.7.1 数据损坏或丢失的错误
### 10.7.2 使用非事务型表
### 10.7.3 混合事务型和非事务型表
### 10.7.4 不确定语句
### 10.7.5 主库和备库使用不同的存储引擎
### 10.7.6 备库发生数据改变
### 10.7.7 不唯一的服务器ID
### 10.7.8 未定义的服务器ID
### 10.7.9 对未复制数据的依赖性
### 10.7.10 丢失的临时表
### 10.7.11 不复制所有的更新
### 10.7.12 InnoDB加锁读引起的锁竞争
### 10.7.13 在主-主复制结构中写入两台主库
### 10.7.14 过大的复制延迟
### 10.7.15 来自主库的过大的包
### 10.7.16 受限制的复制带宽
### 10.7.17 磁盘空间不足
### 10.7.18 复制的局限性
## 10.8 复制有多快
## 10.9 MySQL复制的高级特性
## 10.10 其他复制技术
## 10.11 总结

# 11 可扩展的MySQL
## 11.1 什么是可扩展性
### 11.1.1 正式的可扩展性定义
## 11.2 扩展MySQL
### 11.2.1 规划可扩展性
### 11.2.2 为扩展赢得时间
### 11.2.3 向上扩展
### 11.2.4 向外扩展
### 11.2.5 通过多实例扩展
### 11.2.6 通过集群扩展
### 11.2.7 向内扩展
## 11.3 负载均衡
### 11.3.1 直接连接
### 11.3.2 引入中间件
### 11.3.3 一主多备间的负载均衡
## 11.4 总结
# 12 高可用性
## 12.1 什么是高可用性
## 12.2 导致宕机的原因
## 12.3 如何实现高可用性
### 12.3.1 提升平均失效时间（MTBF）
### 12.3.2 降低平均恢复时间（MTTR）
## 12.4 避免单点失效
### 12.4.1 共享存储或磁盘复制
### 12.4.2 MySQL同步复制
### 12.4.3 基于复制的冗余
## 12.5 故障转移和故障恢复
### 12.5.1 提升备库或切换角色
### 12.5.2 虚拟IP地址或IP接管
### 12.5.3 中间件解决方案
### 12.5.4 在应用中处理故障转移
## 12.6 总结

# 13 云端的MySQL
## 13.1 云的优点、缺点和相关误解
## 13.2 MySQL在云端的经济价值
## 13.3 云中的MySQL的可扩展性和高可用性
## 13.4 四种基础资源
## 13.5 MySQL在云主机上的性能
### 13.5.1 在云端的MySQL基准测试
## 13.6 MySQL数据库即服务（DBaaS）
## 13.7 总结

# 14 应用层优化
## 14.1 常见问题
## 14.2 Web服务器问题
### 14.2.1 寻找最优并发度
## 14.3 缓存
### 14.3.1 应用层以下的缓存
### 14.3.2 应用层缓存
### 14.3.3 缓存控制策略
### 14.3.4 缓存对象分层
### 14.3.5 预生成内容
### 14.3.6 作为基础组件的缓存
### 14.3.7 使用HandlerSocket和memcached
## 14.4 拓展MySQL
## 14.5 MySQL的替代品
## 14.6 总结

# 15 备份与恢复
## 15.1 为什么要备份
## 15.2 定义恢复需求
## 15.3 设计MySQL备份方案
### 15.3.1 在线备份还是离线备份
### 15.3.2 逻辑备份还是物理备份
### 15.3.3 备份什么
### 15.3.4 存储引擎和一致性
## 15.4 管理和备份二进制日志
### 15.4.1 二进制日志格式
### 15.4.2 安全地清除老的二进制日志
## 15.5 备份数据
### 15.5.1 生成逻辑备份
### 15.5.2 文件系统快照
## 15.6 从备份中恢复
### 15.6.1 恢复物理备份
### 15.6.2 还原逻辑备份
### 15.6.3 基于时间点的恢复
### 15.6.4 更高级的恢复技术
### 15.6.5 InnoDB崩溃恢复
## 15.7 备份和恢复工具
### 15.7.1 MySQL Enterprise Backup
### 15.7.2 Percona XtraBackup
### 15.7.3 myIvmbackup
### 15.7.4 Zmanda Recovery Manager
### 15.7.5 mydumper
### 15.7.6 mysqldumper
## 15.8 备份脚本化
## 15.9 总结
# 16 MySQL用户工具
## 16.1 接口工具
## 16.2 命令行工具集
## 16.3 SQL实用集
## 16.4 监测工具
### 16.4.1 开源的监控工具
### 16.4.2 商业监控系统
### 16.4.3 Innotop的命令行监控
## 16.5 总结


\# Note
```
explain 执行计划包含的信息:
其中最重要的字段为：id、type、key、rows、Extra 
```
|id|select_type|table|type|possible_keys|key|key_len|ref|raws|Extra|
|--|-----------|-----|----|-------------|---|-------|---|----|-----|

>1. id
```
id 相同则从上往下执行；
id不同，则id大的先执行；
id相同又不同，参考前两条
```

>2. select_type
```
主要用来区分普通查询、联合查询、子查询等复杂查询：
1、SIMPLE           简单的select查询、查询中不包含子查询或者union查询
2、RIMARY           查询中包含任何复杂的字部分，最外层查询则被标记为primary
3、SUBQUERY         在select或where列表中包含了子查询
4、DERIVED          在from列表中包含的子查询被标记为derived，mysql或递归执行这些子查询，把结果放在临时表里
5、UNION            若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived 
6、UNION RESULT     从union表获取结果的select 
```

>3. type 
```
由好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，好的sql查询至少达到range级别，最好能达到ref
1、system   system是const的特例、一般不会出现
2、const    表示通过一次索引就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const 
3、eq_ref
4、ref
5、range
6、index
7、ALL
```