# 0 Redis开发与运维
# 1 初识Redis
## 1.1 盛赞Redis
## 1.2 Redis 特性
## 1.3 Redis使用场景
### 1.3.1 Redis可以做什么
### 1.3.2 Redis不可以做什么
## 1.4 用好Redis的建议
## 1.5 正确安装并启动Redis
### 1.5.1 安装Redis
### 1.5.2 配置、启动、操作、关闭Redis
## 1.6 Redis重大版本
## 1.7 本章重点回顾
# 2 API的理解和使用
## 2.1 预备
### 2.1.1 全局命令
### 2.1.2 数据结构和内部编码
### 2.1.3 单线程架构
## 2.2 字符串
### 2.2.1 命令
### 2.2.2 内部编码
### 2.2.3 典型使用场景
## 2.3 哈希
### 2.3.1 命令
### 2.3.2 内部编码
### 2.3.3 使用场景
## 2.4 列表
### 2.4.1 命令
### 2.4.2 内部编码
### 2.4.3 使用场景
## 2.5 集合
### 2.5.1 命令
### 2.5.2 内部编码
### 2.5.3 使用场景
## 2.6 有序集合
### 2.6.1 命令
### 2.6.2 内部编码
### 2.6.3 使用场景
## 2.7 键管理
### 2.7.1 单个键管理
### 2.7.2 遍历键
### 2.7.3 数据库管理
## 2.8 本章重点回顾
# 3 小功能大用处
## 3.1 慢查询分析
### 3.1.1 慢查询的两个配置参数
### 3.1.2 最佳实践
## 3.2 Redis Shell
### 3.2.1 redis-cli详解
### 3.2.2 redis-server详解
### 3.2.3 redis-benchmark详解
## 3.3 Pipeline
### 3.3.1 Pipeline概念
### 3.3.2 性能测试
### 3.3.3 原生批量命令与Pipeline对比
### 3.3.4 最佳实践
## 3.4 事务与Lua
### 3.4.1 事务
### 3.4.2 Lua用法简述
### 3.4.3 Redis与Lua
### 3.4.4 案例
### 3.4.5 Redis如何管理Lua脚本
## 3.5 Bitmaps
### 3.5.1 数据结构模型
### 3.5.2 命令
### 3.5.3 Bitmaps分析
## 3.6 HyperLogLog
## 3.7 发布订阅
### 3.7.1 命令
### 3.7.2 使用场景
## 3.8 GEO
## 3.9 本章重点回顾
# 4 客户端
## 4.1 客户端通信协议
## 4.2 Java客户端Jedis
### 4.2.1 获取Jedis
### 4.2.2 Jedis的基本使用方法
### 4.2.3 Jedis连接池的使用方法
### 4.2.4 Redis中Pipeline的使用方法
### 4.2.5 Jedis的Lua脚本
## 4.3 Python客户端redis-py
### 4.3.1 获取redis-py
### 4.3.2 redis-py的基本使用方法
### 4.3.3 redis-py中Pipeline的使用方法
### 4.3.4 redis-py中的Lua脚本使用方法
## 4.4 客户端管理
### 4.4.1 客户端API
### 4.4.2 客户端相关配置
### 4.4.3 客户端统计片段
## 4.5 客户端常见异常
## 4.6 客户端案例分析
### 4.6.1 Redis内存陡增
### 4.6.2 客户端周期性的超时
## 4.7 本章重点回顾
# 5 持久化
## 5.1 RDB
### 5.1.1 触发机制
### 5.1.2 流程说明
### 5.1.3 RDB文件的处理
### 5.1.4 RDB的优缺点
## 5.2 AOF
### 5.2.1 使用AOF
### 5.2.2 命令写入
### 5.2.3 文件同步
### 5.2.4 重写机制
### 5.2.5 重启加载
### 5.2.6 文件校验
## 5.3 问题定位与优化
### 5.3.1 fork操作
### 5.3.2 子进程开销监控和优化
### 5.3.3 AOF追加阻塞
## 5.4 多实例部署
## 5.5 本章重点回顾
# 6 复制
## 6.1 配置
### 6.1.1 建立复制
### 6.1.2 断开复制
### 6.1.3 安全性
### 6.1.4 只读
### 6.1.5 传输延迟
## 6.2 拓扑
## 6.3 原理
### 6.3.1 复制过程
### 6.3.2 数据同步
### 6.3.3 全量复制
### 6.3.4 部分复制
### 6.3.5 心跳
### 6.3.6 异步复制
## 6.4 开发与运维中的问题
### 6.4.1 读写分离
### 6.4.2 主从配置不一致
### 6.4.3 规避全量复制
### 6.4.4 规避复制风暴
## 6.5 本章重点回顾
# 7 Redis的噩梦：阻塞
## 7.1 发现阻塞
## 7.2 内在原因
### 7.2.1 API或数据结构使用不合理
### 7.2.2 CPU饱和
### 7.2.3 持久化阻塞
## 7.3 外在原因
### 7.3.1 CPU竞争
### 7.3.2 内存交换
### 7.3.3 网络问题
## 7.4 本章重点回顾
# 8 理解内存
## 8.1 内存消耗
### 8.1.1 内存使用统计
### 8.1.2 内存消耗划分
### 8.1.3 子进程内存消耗
## 8.2 内存管理
### 8.2.1 设置内存上限
### 8.2.2 动态调整内存上限
### 8.2.3 内存回收策略
## 8.3 内存优化
### 8.3.1 redisObject对象
### 8.3.2 缩减键值对象
### 8.3.3 共享对象池
### 8.3.4 字符串优化
### 8.3.5 编码优化
### 8.3.6 控制键的数量
## 8.4 本章重点回顾
# 9 哨兵
## 9.1 基本概念
### 9.1.1 主从复制的问题
### 9.1.2 高可用
### 9.1.3 Redis Sentinel的高可用性
## 9.2 安装和部署
### 9.2.1 部署拓扑结构
### 9.2.2 部署Redis数据节点
### 9.2.3 部署Sentinel节点
### 9.2.4 配置优化
### 9.2.5 部署技巧
## 9.3 API
## 9.4 客户端连接
### 9.4.1 Redis Sentinel的客户端
### 9.4.2 Redis Sentinel客户端基本实现原理
### 9.4.3 Java操作Redis Sentinel
## 9.5 实现原理
### 9.5.1 三个定时监控任务
### 9.5.2 主观下线和客观下线
### 9.5.3 领导者Sentinel节点选举
### 9.5.4 故障转移
## 9.6 开发与运维中的问题
### 9.6.1 故障转移日志分析
### 9.6.2 节点运维
### 9.6.3 高可用读写分离
## 9.7 本章重点回顾
# 10 集群
## 10.1 数据分布
### 10.1.1 数据分布理论
### 10.1.2 Redis数据分区
### 10.1.3 集群功能限制
## 10.2 搭建集群
### 10.2.1 准备节点
### 10.2.2 节点握手
### 10.2.3 分配槽
### 10.2.4 用redis-trib.rb搭建集群
## 10.3 节点通信
### 10.3.1 通信流程
### 10.3.2 Gossip消息
### 10.3.3 节点选择
## 10.4 集群伸缩
### 10.4.1 伸缩原理
### 10.4.2 扩容集群
### 10.4.3 收缩集群
## 10.5 请求路由
### 10.5.1 请求重定向
### 10.5.2 Smart客户端
### 10.5.3 ASK重定向
## 10.6 故障转移
### 10.6.1 故障发现
### 10.6.2 故障恢复
### 10.6.3 故障转移时间
### 10.6.4 故障转移演练
## 10.7 集群运维
### 10.7.1 集群完整性
### 10.7.2 带宽消耗
### 10.7.3 Pub/Sub广播问题
### 10.7.4 集群倾斜
### 10.7.5 集群读写分离
### 10.7.6 手动故障转移
### 10.7.7 数据迁移
## 10.8 本章重点回顾
# 11 缓存设计
## 11.1 缓存的收益和成本
## 11.2 缓存更新策略
## 11.3 缓存粒度控制
## 11.4 穿透优化
## 11.5 无底洞优化
## 11.6 雪崩优化
## 11.7 热点key重建优化
## 11.8 本章重点回顾
# 12 开发运维的“陷阱”
## 12.1 Linux配置优化
### 12.1.1 内存分配控制
### 12.1.2 swappiness
### 12.1.3 THP
### 12.1.4 OOM killer
### 12.1.5 使用NTP
### 12.1.6 ulimit
### 12.1.7 TCP backlog
## 12.2 flushall/flushdb误操作
### 12.2.1 缓存与存储
### 12.2.2 借助AOF机制恢复
### 12.2.3 RDB有什么变化
### 12.2.4 从节点有什么变化
### 12.2.5 快速恢复数据
## 12.3 安全的Redis
### 12.3.1 Redis密码机制
### 12.3.2 伪装危险命令
### 12.3.3 防火墙
### 12.3.4 bind
### 12.3.5 定期备份数据
### 12.3.6 不使用默认端口
### 12.3.7 使用非root用户启动
## 12.4 处理bigkey
### 12.4.1 bigkey的危害
### 12.4.2 如何发现
### 12.4.3 如何删除
### 12.4.4 最佳实践思路
## 12.5 寻找热点key
## 12.6 本章重点回顾
# 13 Redis监控运维云平台CacheCloud
## 13.1 CacheCloud是什么
### 13.1.1 现有问题
### 13.1.2 CacheCloud基本功能
## 13.2 快速部署
### 13.2.1 CacheCloud环境需求
### 13.2.2 CacheCloud快速开始
## 13.3 机器部署
### 13.3.1 部署脚本
### 13.3.2 添加机器
## 13.4 接入应用
### 13.4.1 总体流程
### 13.4.2 账户申请和审批
### 13.4.3 应用申请和审批
### 13.4.4 客户端接入
## 13.5 用户功能
### 13.5.1 应用统计信息
### 13.5.2 实例列表
### 13.5.3 应用详情
### 13.5.4 命令曲线
### 13.5.5 CacheCloud Redis Shell控制台
### 13.5.6 慢查询
### 13.5.7 应用拓扑
## 13.6 运维功能
### 13.6.1 应用运维
### 13.6.2 接入已存在的Redis节点
### 13.6.3 Redis配置模板
### 13.6.4 迁移工具
### 13.6.5 监控报警
### 13.6.6 系统配置管理
## 13.7 客户端上报
### 13.7.1 客户端上报整体设计
### 13.7.2 Jedis核心代码修改
### 13.7.3 带上报功能的客户端
### 13.7.4 CacheCloud客户端统计
## 13.8 本章重点回顾
# 14 Redis配置统计字典
## 14.1 info系统状态说明
### 14.1.1 命令说明
### 14.1.2 详细说明
## 14.2 standalone配置说明和分析
### 14.2.1 总体配置
### 14.2.2 最大内存及策略
### 14.2.3 AOF相关配置
### 14.2.4 RDB相关配置
### 14.2.5 慢查询配置
### 14.2.6 数据结构优化配置
### 14.2.7 复制相关配置
### 14.2.8 客户端相关配置
### 14.2.9 安全相关配置
## 14.3 Sentinel配置说明和分析
## 14.4 Cluster配置说明和分析