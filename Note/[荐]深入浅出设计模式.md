# 深入浅出设计模式

## 类图(Pre-requment Knowledges)
## 1、类之间的关系
A、一个类是“一种”另一个类：is-a(是一种/一个)关系
B、两个类之间存在关联关系
```
包含：has-a（拥有一个）关系
使用：use-a（使用一个）关系
创建：一个类创建另外一个类
被包含者是包含者的一部分：组合
```
D、有一个集合，集合之中的东西可以独立存在：聚集
E、类的三方面信息：类名、数据成员、方法函数
## 2、表示访问权限的UML记号
A、公开——用一个加号（+）标记
B、保护——用一个井号（#）标记
C、私有——用一个减号（-）标记
## 3、表示关系的UML记号
UML 标记
![UMLmarkup](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/UMLMarkup.png?raw=true)

UML 类图
![classMap](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/classMap.png?raw=true)

## 工厂模式（工厂方法模式/简单工厂模式、抽象工厂模式）
```工厂模式主要为创建对象提供接口，屏蔽具体创建过程，灵活```
### 简单工厂模式    定义一个用于创建对象的接口
![SimpleFactory](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/simpleFactory.JPG?raw=true)
### 工厂方法模式
![FactoryMethod](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/factoryMethod.JPG?raw=true)
### 抽象工厂模式
![abstractFactory](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/abstractFactory.JPG?raw=true)


## 单例模式
![Singleton](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/Singleton.JPG?raw=true)
### Trap
```
分布式、多java VM不适用存在状态的单例模式
多个类加载器（比如java EE服务器中多个servelet引擎，每个引擎采用不同的类加载器）
错误的同步处理  懒汉式单例模式可能会引发死锁
子类破坏了对象控制  如果类构造函数不是私有的（protected），就可能失去对对象的控制，只能通过文档来规范
串行化  每次反串行化都会新生成一个对象,使用以下方法避免，同时还存在基于XML格式的序列化对象也存在这个问题，所以在使用的时候要格外小心
private Object readResolve() {   
    return INSTANCE;   
}   
```

### 题外话  简单的单例模式
```
public static final Singleton INSTANCE = new Singleton();
```

## 建造模式 将复杂对象的构建与它的表示分离
![Build](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/build.JPG?raw=true)
## 原型模式
![prototype](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/prototype.JPG?raw=true)
![prototypeMgr](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/prototypeMgr.JPG?raw=true)

\# prototype和clone在java中存在风险，不建议使用

## 适配器模式   使原本不兼容的接口能在一起工作
![Adapter](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/Adapter.JPG?raw=true)

\# Adapter 强调接口转换     Proxy强调的是不改变接口命名和对已有接口功能的一种控制

## 桥接模式（Birdge）       抽象与实现分离
![Bridge](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/Brige.JPG?raw=true)


## 组合模式
![Composite](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/Composite.JPG?raw=true)

![Composite Compore](https://github.com/rayshaw001/common-pictures/blob/master/designPattern/Composite_Compare.JPG?raw=true)

## 装饰器模式

